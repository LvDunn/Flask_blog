# 数据结构之队列

## 1. 队列的顺序存储（循环队列）

### 1.1 定义
```C
#define MaxSize 50

typedef struct{
    ElemType data[MaxSize];
    int front, rear;
}SqQueue;

```

### 1.2 初始化
```C
void InitQueue(SqQueue *S){
    S.front = S.rear = 0;
}
```

### 1.3 判空
```C
bool Empty(SqQueue S){
    
    if(S.front == S.rear){
        return true;
    }else{
        return false
    }
}
```

### 1.4 入队
```C
bool EnQueue(SqQueue *S, ElemType *e){
    if( (S.rear+1) % MaxSize == S.front){
        return false;
    }
    S.data[S.rear] = e;
    S.rear = (S.rear + 1)%MaxSize;
    return true;
}
```
   
### 1.5 出队
```C
bool DeQueue(SqQueue *S, ElemType e){
    if(S.front == S.rear){
        return false;
    }
    e = S.data[S.front];
    S.front = (S.front + 1)%MaxSize;
    return true;
}
```

### 1.6 队长
```C
int GetLength(SqQueue S){
    
    return (S.rear - S.front + MaxSize)%MaxSize;
}
```

## 队列的链式存取结构

### 2.1 定义
```C
typedef struct{
    ElemType data;
    Struct LinkNode *next;
}LinkNode;

typedef struct{
    LinkNode *front, *rear;
}LinkQueue;
```

### 2.2 初始化
```C
void InitQueue(LinkQueue *Q){
    Q.front = Q.rear = (LinkNode *)malloc(sizeof(LinkNode));
    Q.front->next = NULL;
}
```
### 2.3 判空
```C
bool Empty(LinkQueue Q){
    if(Q.front == Q.rear){
        return true;
    }else{
        return false;
    }
}
```

### 2.4 入队
```C
void EnQueue(LinkQueue *Q, ElemType e){
    
    s = (LinkNode *)malloc(sizeof(LinkNode));
    s->data = e;
    s->next = NULL:
    Q.rear = s;
}
```

### 2.5 出队
```C
void DeQueue(LinkQueue *Q, ElemType *e){
    if(Q.front == Q.rear){
        return false;
    }
    p = Q.front->next;
    e = p->data;
    Q.front->next = p->next;
    if(Q.rear = p){
        Q.rear = Q.front;
    }
    free(p);
    return true;
}
```

