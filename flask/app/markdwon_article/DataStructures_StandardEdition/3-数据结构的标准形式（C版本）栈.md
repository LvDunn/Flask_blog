# 数据结构之栈

[TOC]

## 1. 顺序栈的实现

### 1.1 定义
```C
# define MaxSize 50

typedef struct{
    ElemType data[MaxSzie];
    int top;
} Stack, PStack;
```
### 1.2 初始化
```C
void InitStrack(PStack S){
    s.top = -1;
}
```

### 1.3 判空
```C
bool Empty(S){
    if(s.top == -1){
        return true;
    }else{
        return false;
    }
}
```

### 1.4 入栈
```C
bool Push(PStack S, ElemType e){
    
    if(s.top == MaxSize -1){
        return false;
    }
    S.data[++S.top] == e;
    return true;
}
```

### 1.5 出栈
```C
bool Pop(PStack S, ElemType *e){
    
    if(S.top == -1){
        return false;
    }
    e = S.data[S.top--];
    return false

}
```

### 1.6 读栈顶元素
```C
bool GetTop(Stack S, ElemType *e){

    if(S.top == -1){
        return false;
    }
    e = S.data[S.top];
    return true;
}
```

### 1.7 栈的长度
```C
int GetStackLenth(Stack S){
    
    return S.top + 1;
}
```

### 1.8 清空
```C
void StackClear(Stack S){
    
    s.top = -1;
    return true;

}
```
## 2. 链栈

### 2.1 定义
```C
typedef struct LNode{
    ElemType data;
    LinkStack *next;
} LinkNode;

typedef struck LStack{
    pNode top;
    int length;
}*LinkStack;
```

### 2.2 初始化
```C
void InitStack(LinkSatck *S){
    
    *S = (LinkStack)malloc(sizeof(LinkStack));
    (*S)->top = NULL;
    (*S)->length = 0;
    return true;
}
```

### 2.3 判空
```C
bool Empty(LinkStack S){
    
    if(S->top == NULL){
        return true;
    }else{
        return false;
    }

}
```

### 2.4 入栈
```C
bool Push(LinkStack S, ElemType e){

    LNode *p;
    if(S->lenth = MaxSize-1){
        return false;
    }
    p = (LinkNode)malloc(sizeof(LinkNode));
    if(p == NULL){
        return false;
    }
    p->data = e;
    p-next = S->top;
    S->top = p;
    S->lenth++;

    return true;
}
```

### 2.5 出栈
```C
bool Pop(LinkStack S, ElemType *e){

    if(Empty(S)){
        return false;
    }
    
    LinkNode *tmp = S->top;
    S->top = tmp->next;
    S->lenth--;
    e = tmp->data;

    free(tmp)
    return true;
}
```

### 2.6 获取栈顶
```C
bool GetTop(LinkSatck S, ElemType *e){
    if(Empty(S)){
        return false;
    }
    
    e = S->top->data;
    return true;
}
```

### 2.7 栈长
```C
int GetStackLenth(LStack S){
    
    return S->lenth;
}
```

### 2.7 置空链表
```C
bool ClearStack(LinkStack S){
    if(Empty(S)){
        return true;
    }
    LinkNode *tmp = S->top;
    while(top){
        tmp = top;
        S->top = tmp->next;
        S->lenth--;
        free(tmp)
    }
    return bool;
}
```
### 2.8 销毁
```C
void Destroy(LinkStack *S){
    ClearStack(S);
    free(*S);
    return true;
}
```


















